pragma solidity ^0.4.18;

import './zeppelin-solidity/contracts/token/ERC20.sol';
import './zeppelin-solidity/contracts/math/SafeMath.sol';

contract RestrictedUserListTransaction is ERC20 {
    using SafeMath for uint256;

    string internal constant SYMBOL = "RULT";
    string internal constant NAME = "Restricted UserList Transaction";
    uint internal constant DECIMALS = 18; 

    struct User {
        string name;
        address addr;
        uint256 balance;
        uint256 userNumber;
        mapping (address => uint) allowedAccounts;
    }

    uint256 numberOfUsers;
    mapping (uint256 => User) userList;

    address public owner;
    modifier onlyOwner () {
        require(msg.sender == owner);
        _;
    }

    function RestrictedUserListTransaction () public {
        owner = msg.sender;
        numberOfUsers = 1;
        totalSupply = 100000000; //1 coin states 1 kuru≈ü, in total 1 millon TL
        userList[numberOfUsers] = User("Engin", msg.sender, totalSupply, numberOfUsers);
    }

    //Owner related part similar to Ownable contract in zepplin-solidity. 
    event OwnershipTransferred (address indexed previousOwner, address indexed newOwner);

    function transferOwnership (address newOwner) onlyOwner public {
        require (newOwner != address(0));
        owner = newOwner;
        OwnershipTransferred(owner, newOwner);
    }

    //Minting related part
    event Mint(uint256 amount);

    function mint (uint256 amount) onlyOwner public returns (bool) {
        totalSupply = totalSupply.add(amount);
        userList[getUserNumber(owner)].balance = userList[getUserNumber(owner)].balance.add(amount);
        Mint(amount);
        return true; 
    } 

    // may need to check if input address is belog to a user in userList
    function getUserNumber(address addr) private view returns (uint256) {
        for (uint256 i = 0; i < numberOfUsers; i.add(1)) { //i.add(1) is enough or should I user i = i.add(1)
            if (userList[i].addr == addr) {
                return i;
            }
        }
    }

    //ERC20Basic related part
    function balanceOf(address who) public constant returns (uint256) {
        return userList[getUserNumber(who)].balance;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        uint256 userNumber = getUserNumber(msg.sender);
        uint256 targetUserNumber = getUserNumber(to);

        require(to != address(0));
        require(userList[targetUserNumber].addr != address(0));
        require(value <= userList[userNumber].balance);

        userList[userNumber].balance = userList[userNumber].balance.sub(value);
        userList[targetUserNumber].balance = userList[targetUserNumber].balance.add(value);
        Transfer(msg.sender, to, value);
        return true; 
    }

    //if user already add spender than just increases the number
    //if user does not has spender in his allowed account list than adds is to the list
    function approve (address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        uint256 userNumber = getUserNumber(msg.sender);
        userList[userNumber].allowedAccounts[spender] = userList[userNumber].allowedAccounts[spender].add(value);
        Approval(msg.sender, spender,  value);
        return true;
    
    }

    function allowance(address owner, address spender) public returns (uint256) {
        require(owner != address(0));
        require(spender != address(0));

        return userList[getUserNumber(owner)].allowedAccounts[spender];
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool){
        
        require(to != address(0));
        require(from != address(0));
        
        uint256 fromUserNumber = getUserNumber(from);
        uint256 toUserNumber = getUserNumber(to);

        require(value <= userList[fromUserNumber].balance);
        require(value <= userList[fromUserNumber].allowedAccounts[msg.sender]);

        userList[fromUserNumber].balance = userList[fromUserNumber].balance.sub(value);
        userList[toUserNumber].balance = userList[toUserNumber].balance.add(value);
        userList[fromUserNumber].allowedAccounts[msg.sender] = userList[fromUserNumber].allowedAccounts[msg.sender].sub(value);
        return true;
    }

    event AddUser(string name, address addr, uint256 value, uint userNumber);
    function addUser(string name, address addr, uint256 value) onlyOwner public returns (bool){
        require(value <= userList[getUserNumber(owner)].balance);
        require(addr != address(0));

        userList[getUserNumber(owner)].balance = userList[getUserNumber(owner)].balance.sub(value);
        numberOfUsers = numberOfUsers.add(1);
        userList[numberOfUsers].name = name;
        userList[numberOfUsers].addr = addr;
        userList[numberOfUsers].balance = value;
        userList[numberOfUsers].userNumber = numberOfUsers;
        AddUser(name, addr, value, numberOfUsers);
        return true;
    }




}